# テスト実行ガイド

このドキュメントは、このプロジェクトでテストを実行する際の注意点と、過去に発生した問題の解決策をまとめたものです。

## テストの実行方法

いつでも以下のコマンドでテストスイート全体を実行できます。

```bash
npm test
```

変更をコミットする前には、必ずこのコマンドを実行し、すべてのテストがパスすることを確認してください。

## テスト環境のセットアップ

現在のテスト環境は、実際のデータベース（Turso）に接続するのではなく、テスト実行のたびにメモリ上に一時的なデータベースを構築して動作します。これにより、外部サービスに依存しない、高速で安定したテストが可能になっています。

- **グローバルセットアップ**: `tests/setup-test-env.ts`
  - ここで `vitest` の `vi.mock` を使い、アプリケーション全体のデータベース接続をテスト用のものに差し替えています。
  - また、すべてのテストが実行される前にデータベースのテーブルを作成し、すべてのテストが終わった後にテーブルを削除する処理を担っています。
- **テスト用データベース定義**: `tests/setup-test-db.ts`
  - メモリ上で動作するSQLiteデータベースをセットアップし、テーブルの作成・削除を行う具体的なロジックが書かれています。

### 注意：新しいテーブルをスキーマに追加した場合

`src/lib/server/db/schema.ts` に新しいテーブル定義を追加した場合は、必ず `tests/setup-test-db.ts` ファイルも更新してください。

1.  `createTables` 関数に、新しいテーブルの `CREATE TABLE` 文を追加します。
2.  `dropTables` 関数に、新しいテーブルの `DROP TABLE IF EXISTS` 文を追加します。

これを忘れると、そのテーブルを操作するテストが「no such table」エラーで失敗します。

## 過去に発生したテストの失敗と解決策（デバッグの記録）

今回のNetlify対応作業の過程で、テストスイートにいくつかの根深い問題があることが判明しました。同様の問題に直面した場合の参考として、その解決過程を記録します。

### 1. `no such table` エラー (テーブルが見つからない)

- **問題**: 統合テストを実行すると、「no such table: user」のようなエラーで失敗しました。
- **原因**:
    1. 当初、テストが使用するデータベースドライバと、本番コードが使用するドライバが異なっていました (`better-sqlite3` vs `@libsql/client`)。
    2. `vite.config.ts`のエイリアス設定でデータベース接続をモックしようとしていましたが、うまく機能していませんでした。
    3. 最終的に、テストセットアップ用の`createTables`関数に、必要なテーブル (`tags`, `note_tags`) の作成定義が漏れていることが判明しました。
- **解決策**:
    1. テスト用のDBセットアップ (`tests/setup-test-db.ts`) が、本番と同じ `@libsql/client` を使うように修正しました。
    2. 信頼性の低いエイリアス設定をやめ、`tests/setup-test-env.ts` で `vi.mock` を使って明示的にDB接続をモックする方法に切り替えました。
    3. `tags`と`note_tags`テーブルを作成するSQL文を`createTables`関数に追加しました。

### 2. 特定のテストがどうしても失敗する問題

- **問題**: データベースのセットアップを修正した後も、重複したタイトルのノートの中から最新のものを返すことを確認するテスト (`should return the latest updated note for duplicate titles`) だけが失敗し続けました。
- **原因**:
    - **根本原因はDBスキーマの設計ミスでした。** `src/lib/server/db/schema.ts` の `notes` テーブル定義で、`slug` カラムに `unique()` 制約が付いていました。これにより、すべてのノートでスラグがユニークでなければならず、テストが意図していた「同一ユーザーが同じスラグのノートを複数持つ」という状況を作れずにいました。
    - テストコードは `onConflictDoNothing()` を使ってデータを挿入していたため、ユニーク制約違反がエラーにならず、2つ目以降のデータが単に無視されていました。その結果、テストは常に最初に挿入されたデータのみを対象としてしまい、期待通りに動作しませんでした。
- **解決策**:
    - `src/lib/server/db/schema.ts` から `slug` の `unique()` 制約を削除しました。
    - これにより、テストは正しく複数の重複スラグを持つノートを作成できるようになり、APIがその中から最新のものを返す、という本来のロジックを正しくテストできるようになりました。

このデバッグの旅は長くなりましたが、結果としてアプリケーションの堅牢性を大きく向上させることができました。今後の開発でも、テストがうまく動かない場合は、テストコードだけでなく、テスト対象のコードや、さらにはその土台となるスキーマ定義まで疑ってみることが重要です。
